# FurhatJSCore

Client library for connecting to and operating FurhatOS (read more at: www.furhatrobotics.com)

## Usage

Install using:

    npm install furhat-core

Import (ES6 import syntax) using:

    import Furhat from 'furhat-core'

Initialize the connection:

    let furhat = new Furhat('localhost', 80, 'api')

    furhat.init()
      .then(({error, message}) => {
        if(error) {
          console.log('Something went wrong:', message)
          return
        }
        
        furhat.say('I am connected!')
      })
      .catch(({error, message}) => console.log('Something went wrong:', message))
      
    // or you can use the async/await syntax
    try {
      const {error, message} = await furhat.init()
      if(error) {
        console.log('Something went wrong:', message)
        return
      }
      
      furhat.say('I am connected!')
    } catch({error, message}) {
      console.log('Something went wrong:', message)
    }

## API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

#### Table of Contents

-   [Furhat](#furhat)
    -   [init](#init)
    -   [send](#send)
    -   [subscribe](#subscribe)
    -   [subscribeGroup](#subscribegroup)
    -   [say](#say)
    -   [userSpeech](#userspeech)
    -   [userSpeechStart](#userspeechstart)
    -   [gesture](#gesture)

### Furhat

Furhat main class. Maintains the websocket connection to furhatOS and
has methods to send events, subscribe to events and helper methods such as say,
gesture, etc.

**Parameters**

-   `domain`  IP Address for furhatOS - localhost if SDK.
-   `port`  port for RealTimeAPI module of furhatOS.
-   `route`  route for RealTimeAPI module of furhatOS.

#### init

Initializes the connection and return a promise. Await for the promise to resolve before
using the object

#### send

Sends an event to furhatOS

**Parameters**

-   `event`  Object containing the event. Mandtory to have event_name parameter in the object

#### subscribe

Subscribes to the given event and triggers the supplied callback on event

**Parameters**

-   `eventName`  Name of the event to subscribe
-   `callback`  Function which needs to be triggered when the given event is recieved
-   `dontSend`  [Optional][false by default] Boolean which determines wether to send
    the subscribe event or not. use it to set callbacks for event that are already subscribed to,
    for instance with group subscriptions

#### subscribeGroup

Subscribes to the given event group

**Parameters**

-   `groupNumber`  Number(Assigned ENUM) of the group that needs to be subscribed to

#### say

Says a given text

**Parameters**

-   `text`  Text which needs to be said by Furhat

#### userSpeech

Stimulates the speech of a user in the interaction space

**Parameters**

-   `text`  Text which needs to be said by the user

#### userSpeechStart


Stimulates SenseSpeechStart event. Can be used to stimulate user speech via typing

#### gesture

Performs the given gesture

**Parameters**

-   `name`  Name of the gesture that needs to be performed

How the DASS-21 test can be customized for DASS-42 is presented. This includes the number of statements, answer options, scale and assessment. Customizing the Number of Statements: Open the project and go to 'idle.kt', line 68. Change the variable val maxStatements = 21 to the number of statements in your customized test. In the start.kt define how many states you have and correspondingly how many state_scores you need. There are three scores in the template (scoreS, scoreA and scoreD). Exclude any scores you don't require, specifically, the scores that are unnecessary for your use case. Changing the Test Description: In 'newTest.kt', line 17, update the description of the test. Inserting Statements with Alternatives: Go to 'questionlist.kt' to insert your statements with the alternatives. You can add or remove Question constructors. Handling Correct Answers: The correct answer is taken from the resources folder. Check 'nlu.kt', line 10. Processing User Responses: User responses are processed in 'askQuestion.kt', for instance, line 60 processes onResponse and assigns 1 point to the appropriate score (depression, anxiety, or stress) based on the statement. Assessing Severity: In 'endTest'.kt, line 15, you need to change the function assessSeverity with your own assessment. Also, review lines 40-42 for the assessment of severity for each category.

Similarly, the Perceived Stress Scale (PSS) can be personalised in the same way. Adjusting the Number of Statements: Open the project and navigate to 'idle.kt' at line 68. Modify the variable val maxStatements = 10 to reflect the number of statements in your personalised test. In the start.kt define the state, which is stress, and how many state_scores you need. Individual scores on the PSS can range from 0 to 40 with higher scores indicating higher perceived stress. Updating the Test Description: In 'newTest.kt' at line 17, modify the test description. Adding Statements with Alternatives: Navigate to 'questionlist.kt' to insert your statements along with their alternatives, which can be never, almost never, sometimes, often and very often. Managing Correct Answers: The correct answer is sourced from the resources folder. Refer to 'nlu.kt' at line 10. The scores vary from 0 to 4 according to the alternatives. However, questions 4, 5, 7 and 8 are reversed. For evaluating Severity: in the 'endTest.kt' at line 15, replace the function assessSeverity with the assessment method. In this case there are three ranges for stress - low, moderate and high perceived stress.
